AmqpMgr maintains a list of Hosts that have been connected to.
-> State = [{Host, HostInfo}]

Each host entry contains the connection and monitor ref, and the channel, the process requesting the channel, monitor ref and ticket.
-> HostInfo = [
    {connection, pid(), reference()}
    ,{pid(), pid(), reference(), integer()}
  ]
-> HostInfo = [
    {connection, Connection, MRef}
    ,{ProcessPid, ChannelPid, MRef, Ticket}
  ]

When a process wants to create an exchange, it will call amqp_util:*_exchange(Host). amqp_util:*_exchange(Host) will in turn make a call to amqp_manager:open_channel(Pid, Host).
If the Host is unknown, a new HostInfo will be created, creating a new connection.
If the process pid is unknown, a 4-tuple will be added to the HostInfo, creating a new Channel/Ticket.
The Channel/Ticket will be returned to amqp_util, which will call the appropriate amqp_channel:(cast|call).

If a ProcessPid goes down, all Hosts will be searched for reference to the ProcessPid and the 4-tuple removed from the HostInfo.

If a Channel goes down, all Hosts will be searched for reference to the Channel. Any found 4-tuples will be removed. If we can restart the Channel and get a new Ticket, great! Create the new 4-tuple with the old ProcessPid. If creating the Channel fails, alert the ProcessPid ({amqp_channel_down, Host})and remove the 4-tuple completely.

If a connection goes down, find the HostInfo entry. If the connection can be restarted, re-create all the Channel/Ticket combos with the old ProcessPids, following the Channel-restart process above. If the connection cannot be restarted, alert all ProcessPids ({amqp_host_down, Host}), close all ChannelPids, and remove the Host from the state.
