#!/bin/sh
##
##   OCF Resource Agent compliant rabbitmq-server resource script.
##

##   The contents of this file are subject to the Mozilla Public License
##   Version 1.1 (the "License"); you may not use this file except in
##   compliance with the License. You may obtain a copy of the License at
##   http://www.mozilla.org/MPL/
##
##   Software distributed under the License is distributed on an "AS IS"
##   basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
##   License for the specific language governing rights and limitations
##   under the License.
##
##   The Original Code is RabbitMQ.
##
##   The Initial Developers of the Original Code are LShift Ltd,
##   Cohesive Financial Technologies LLC, and Rabbit Technologies Ltd.
##
##   Portions created before 22-Nov-2008 00:00:00 GMT by LShift Ltd,
##   Cohesive Financial Technologies LLC, or Rabbit Technologies Ltd
##   are Copyright (C) 2007-2008 LShift Ltd, Cohesive Financial
##   Technologies LLC, and Rabbit Technologies Ltd.
##
##   Portions created by LShift Ltd are Copyright (C) 2007-2010 LShift
##   Ltd. Portions created by Cohesive Financial Technologies LLC are
##   Copyright (C) 2007-2010 Cohesive Financial Technologies
##   LLC. Portions created by Rabbit Technologies Ltd are Copyright
##   (C) 2007-2010 Rabbit Technologies Ltd.
##
##   All Rights Reserved.
##
##   Contributor(s): ______________________________________.
##

## OCF instance parameters
##   OCF_RESKEY_multi
##   OCF_RESKEY_ctl
##   OCF_RESKEY_nodename
##   OCF_RESKEY_ip
##   OCF_RESKEY_port
##   OCF_RESKEY_cluster_config_file
##   OCF_RESKEY_config_file
##   OCF_RESKEY_log_base
##   OCF_RESKEY_mnesia_base
##   OCF_RESKEY_server_start_args

#######################################################################
# Initialization:

: ${OCF_FUNCTIONS_DIR=${OCF_ROOT}/resource.d/heartbeat}
. ${OCF_FUNCTIONS_DIR}/.ocf-shellfuncs

#######################################################################

OCF_RESKEY_multi_default="/usr/sbin/rabbitmq-multi"
OCF_RESKEY_ctl_default="/usr/sbin/rabbitmqctl"
OCF_RESKEY_nodename_default="rabbit@localhost"
OCF_RESKEY_log_base_default="/var/log/rabbitmq"
: ${OCF_RESKEY_multi=${OCF_RESKEY_multi_default}}
: ${OCF_RESKEY_ctl=${OCF_RESKEY_ctl_default}}
: ${OCF_RESKEY_nodename=${OCF_RESKEY_nodename_default}}
: ${OCF_RESKEY_log_base=${OCF_RESKEY_log_base_default}}

meta_data() {
    cat <<END
<?xml version="1.0"?>
<!DOCTYPE resource-agent SYSTEM "ra-api-1.dtd">
<resource-agent name="rabbitmq-server">
<version>1.0</version>

<longdesc lang="en">
Resource agent for RabbitMQ-server
</longdesc>

<shortdesc lang="en">Resource agent for RabbitMQ-server</shortdesc>

<parameters>
<parameter name="multi" unique="0" required="0">
<longdesc lang="en">
The path to the rabbitmq-multi script
</longdesc>
<shortdesc lang="en">Path to rabbitmq-multi</shortdesc>
<content type="string" default="${OCF_RESKEY_multi_default}" />
</parameter>

<parameter name="ctl" unique="0" required="0">
<longdesc lang="en">
The path to the rabbitmqctl script
</longdesc>
<shortdesc lang="en">Path to rabbitmqctl</shortdesc>
<content type="string" default="${OCF_RESKEY_ctl_default}" />
</parameter>

<parameter name="nodename" unique="0" required="0">
<longdesc lang="en">
The node name for rabbitmq-server
</longdesc>
<shortdesc lang="en">Node name</shortdesc>
<content type="string" default="${OCF_RESKEY_nodename_default}" />
</parameter>

<parameter name="ip" unique="0" required="0">
<longdesc lang="en">
The IP address for rabbitmq-server to listen on
</longdesc>
<shortdesc lang="en">IP Address</shortdesc>
<content type="string" default="" />
</parameter>

<parameter name="port" unique="0" required="0">
<longdesc lang="en">
The IP Port for rabbitmq-server to listen on
</longdesc>
<shortdesc lang="en">IP Port</shortdesc>
<content type="integer" default="" />
</parameter>

<parameter name="cluster_config_file" unique="0" required="0">
<longdesc lang="en">
Location of the cluster config file
</longdesc>
<shortdesc lang="en">Cluster config file path</shortdesc>
<content type="string" default="" />
</parameter>

<parameter name="config_file" unique="0" required="0">
<longdesc lang="en">
Location of the config file
</longdesc>
<shortdesc lang="en">Config file path</shortdesc>
<content type="string" default="" />
</parameter>

<parameter name="log_base" unique="0" required="0">
<longdesc lang="en">
Location of the directory under which logs will be created
</longdesc>
<shortdesc lang="en">Log base path</shortdesc>
<content type="string" default="${OCF_RESKEY_log_base_default}" />
</parameter>

<parameter name="mnesia_base" unique="0" required="0">
<longdesc lang="en">
Location of the directory under which mnesia will store data
</longdesc>
<shortdesc lang="en">Mnesia base path</shortdesc>
<content type="string" default="" />
</parameter>

<parameter name="server_start_args" unique="0" required="0">
<longdesc lang="en">
Additional arguments provided to the server on startup
</longdesc>
<shortdesc lang="en">Server start arguments</shortdesc>
<content type="string" default="" />
</parameter>

</parameters>

<actions>
<action name="start"        timeout="600" />
<action name="stop"         timeout="120" />
<action name="status"       timeout="20" interval="10" />
<action name="monitor"      timeout="20" interval="10" />
<action name="validate-all" timeout="30" />
<action name="meta-data"    timeout="5" />
</actions>
</resource-agent>
END
}

rabbit_usage() {
    cat <<END
usage: $0 {start|stop|status|monitor|validate-all|meta-data}

Expects to have a fully populated OCF RA-compliant environment set.
END
}

RABBITMQ_MULTI=$OCF_RESKEY_multi
RABBITMQ_CTL=$OCF_RESKEY_ctl
RABBITMQ_NODENAME=$OCF_RESKEY_nodename
RABBITMQ_NODE_IP_ADDRESS=$OCF_RESKEY_ip
RABBITMQ_NODE_PORT=$OCF_RESKEY_port
RABBITMQ_CLUSTER_CONFIG_FILE=$OCF_RESKEY_cluster_config_file
RABBITMQ_CONFIG_FILE=$OCF_RESKEY_config_file
RABBITMQ_LOG_BASE=$OCF_RESKEY_log_base
RABBITMQ_MNESIA_BASE=$OCF_RESKEY_mnesia_base
RABBITMQ_SERVER_START_ARGS=$OCF_RESKEY_server_start_args
[ ! -z $RABBITMQ_NODENAME ] && NODENAME_ARG="-n $RABBITMQ_NODENAME"
[ ! -z $RABBITMQ_NODENAME ]            && export RABBITMQ_NODENAME

export_vars() {
    [ ! -z $RABBITMQ_NODE_IP_ADDRESS ]     && export RABBITMQ_NODE_IP_ADDRESS
    [ ! -z $RABBITMQ_NODE_PORT ]           && export RABBITMQ_NODE_PORT
    [ ! -z $RABBITMQ_CLUSTER_CONFIG_FILE ] && export RABBITMQ_CLUSTER_CONFIG_FILE
    [ ! -z $RABBITMQ_CONFIG_FILE ]         && export RABBITMQ_CONFIG_FILE
    [ ! -z $RABBITMQ_LOG_BASE ]            && export RABBITMQ_LOG_BASE
    [ ! -z $RABBITMQ_MNESIA_BASE ]         && export RABBITMQ_MNESIA_BASE
    [ ! -z $RABBITMQ_SERVER_START_ARGS ]   && export RABBITMQ_SERVER_START_ARGS
}

rabbit_validate_partial() {
    if [ ! -x $RABBITMQ_MULTI ]; then
        ocf_log err "rabbitmq-server multi $RABBITMQ_MULTI does not exist or is not executable";
        exit $OCF_ERR_INSTALLED;
    fi

    if [ ! -x $RABBITMQ_CTL ]; then
        ocf_log err "rabbitmq-server ctl $RABBITMQ_CTL does not exist or is not executable";
        exit $OCF_ERR_INSTALLED;
    fi
}

rabbit_validate_full() {
    if [ ! -z $RABBITMQ_CLUSTER_CONFIG_FILE ] && [ ! -e $RABBITMQ_CLUSTER_CONFIG_FILE ]; then
        ocf_log err "rabbitmq-server cluster_config_file $RABBITMQ_CLUSTER_CONFIG_FILE does not exist or is not a file";
        exit $OCF_ERR_INSTALLED;
    fi

    if [ ! -z $RABBITMQ_CONFIG_FILE ] && [ ! -e $RABBITMQ_CONFIG_FILE ]; then
        ocf_log err "rabbitmq-server config_file $RABBITMQ_CONFIG_FILE does not exist or is not a file";
        exit $OCF_ERR_INSTALLED;
    fi

    if [ ! -z $RABBITMQ_LOG_BASE ] && [ ! -d $RABBITMQ_LOG_BASE ]; then
        ocf_log err "rabbitmq-server log_base $RABBITMQ_LOG_BASE does not exist or is not a directory";
        exit $OCF_ERR_INSTALLED;
    fi

    if [ ! -z $RABBITMQ_MNESIA_BASE ] && [ ! -d $RABBITMQ_MNESIA_BASE ]; then
        ocf_log err "rabbitmq-server mnesia_base $RABBITMQ_MNESIA_BASE does not exist or is not a directory";
        exit $OCF_ERR_INSTALLED;
    fi

    rabbit_validate_partial

    return $OCF_SUCCESS
}

rabbit_status() {
    local rc
    $RABBITMQ_CTL $NODENAME_ARG status > /dev/null 2> /dev/null
    rc=$?
    case "$rc" in
        0)
            ocf_log debug "RabbitMQ server is running normally"
            return $OCF_SUCCESS
            ;;
        2)
            ocf_log debug "RabbitMQ server is not running"
            return $OCF_NOT_RUNNING
            ;;
        *)
            ocf_log err "Unexpected return from rabbitmqctl $NODENAME_ARG status: $rc"
            exit $OCF_ERR_GENERIC
    esac
}

rabbit_start() {
    local rc

    if rabbit_status; then
        ocf_log info "Resource already running."
        return $OCF_SUCCESS
    fi

    export_vars

    $RABBITMQ_MULTI start_all 1 > ${RABBITMQ_LOG_BASE}/startup_log 2> ${RABBITMQ_LOG_BASE}/startup_err &
    rc=$?

    if [ "$rc" != 0 ]; then
        ocf_log err "rabbitmq-server start command failed: $RABBITMQ_MULTI start_all 1, $rc"
        return $rc
    fi

    # Spin waiting for the server to come up.
    # Let the CRM/LRM time us out if required
    start_wait=1
    while [ $start_wait = 1 ]; do
        rabbit_status
        rc=$?
        if [ "$rc" = $OCF_SUCCESS ]; then
            start_wait=0
        elif [ "$rc" != $OCF_NOT_RUNNING ]; then
            ocf_log info "rabbitmq-server start failed: $rc"
            exit $OCF_ERR_GENERIC
        fi
        sleep 1
    done

    return $OCF_SUCCESS
}

rabbit_stop() {
    local rc

    if ! rabbit_status; then
        ocf_log info "Resource not running."
        return $OCF_SUCCESS
    fi

    $RABBITMQ_MULTI stop_all &
    rc=$?

    if [ "$rc" != 0 ]; then
        ocf_log err "rabbitmq-server stop command failed: $RABBITMQ_MULTI stop_all, $rc"
        return $rc
    fi

    # Spin waiting for the server to shut down.
    # Let the CRM/LRM time us out if required
    stop_wait=1
    while [ $stop_wait = 1 ]; do
        rabbit_status
        rc=$?
        if [ "$rc" = $OCF_NOT_RUNNING ]; then
            stop_wait=0
            break
        elif [ "$rc" != $OCF_SUCCESS ]; then
            ocf_log info "rabbitmq-server stop failed: $rc"
            exit $OCF_ERR_GENERIC
        fi
        sleep 1
    done

    return $OCF_SUCCESS
}

rabbit_monitor() {
    rabbit_status
    return $?
}

case $__OCF_ACTION in
    meta-data)
        meta_data
        exit $OCF_SUCCESS
        ;;
    usage|help)
        rabbit_usage
        exit $OCF_SUCCESS
        ;;
esac

if ocf_is_probe; then
    rabbit_validate_partial
else
    rabbit_validate_full
fi

case $__OCF_ACTION in
    start)
        rabbit_start
        ;;
    stop)
        rabbit_stop
        ;;
    status|monitor)
        rabbit_monitor
        ;;
    validate-all)
        exit $OCF_SUCCESS
        ;;
    *)
        rabbit_usage
        exit $OCF_ERR_UNIMPLEMENTED
        ;;
esac

exit $?
